# Разработка программного комплекса для подготовки документов

1. [Описание проекта](#Description)
2. [Первичные настройки библиотеки](#Settings)
3. [Работа с документами типа .doc](#Doc)
4. [Работа с документами типа .docx](#Docx)
5. [Работа с несколькими авторами](#Authors)
6. [Конвертация в PDF](#ConvertPDF)
7. [Оконное приложение](#Window)
8. [Тестирование](#Testing)
9. [Возникшие проблемы](#Problems)
10. [Лицензия](#License)
11. [Авторы](#ProjectAuthors)

## <a name="Description"></a> 1. Описание проекта

Этот проект представляет собой программный комплекс, разработанный на языке Java, который обеспечивает возможность подготовки документов по шаблону в форматах .doc и .docx. Для достижения этой цели используется библиотека Apache POI.

## <a name="Settings"></a> 2. Первичные настройки библиотеки

Apache POI представляет собой API, который позволяет использовать файлы MS Office в Java приложениях. Данная библиотека разрабатывается и распространяется Apache Software Foundation и носит открытый характер. Apache POI включает классы и методы для чтения и записи информации в документы MS Office.

В проекте используется фреймворк Maven, необходимо установить следующие зависимости: 
- [poi-ooxml](https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml) - чтобы редактировать файлы .docx:

```
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
    <version>5.2.5</version>
</dependency>
```

- [poi-scratchpad](https://mvnrepository.com/artifact/org.apache.poi/poi-scratchpad) - для работы с файлами .doc:

```
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-scratchpad</artifactId>
    <version>5.2.5</version>
</dependency>
```

Так как мы работаем в среде IntelliJ IDEA, нужно перезагрузить проект Maven, при необходимости скачать индексы.

## <a name="Doc"></a> 3. Работа с документами типа .doc

### Описание структуры файлов .doc

Файлы с расширением .doc представляют собой формат документов Microsoft Word, использовавшийся до появления формата .docx. В отличие от более новых форматов на основе XML, файлы .doc являются бинарными файлами, что делает их более сложными для анализа и обработки без специализированных библиотек.

**Основные компоненты файла .doc:**

1. Сегменты документа: основной текст, заголовки, сноски, комментарии и другие элементы.
2. Форматирование: информация о шрифтах, стилях, абзацах и форматировании текста.
3. Объекты: изображения, таблицы, диаграммы и другие вложенные объекты.
4. Ссылки и метки: гиперссылки, закладки и другие ссылки внутри документа.

Для работы с такими документами используется модуль HWPF (Horrible Word Processor Format) для работы с форматом .doc.

### Класс WordDOC

Предназначен для изменения содержимого документов формата .doc. Он предоставляет функциональность для замены текстовых меток на указанные значения, используя библиотеку Apache POI и объект POIFSFileSystem.

**Основные методы:**

- changeFile - метод для извлечения документа из указанного файла, заменяет текстовые метки на указанные значения и сохраняет изменения в новом файле.

- replaceText - метод для замены текстовые метки в документе на значения из TagMap. Для этого он перебирает все текстовые метки и выполняет замену текста в диапазоне Range.

- saveFile - метод для сохранения измененный документ в новый файл.

## <a name="Docx"></a> 4. Работа с документами типа .docx

### Описание структуры файлов .docx

Файлы с расширением .docx представляют собой формат документов Microsoft Word, основанный на стандарте Office Open XML. В отличие от старого формата .doc, .docx — это сжатый ZIP-архив, содержащий множество XML-файлов и других ресурсов.

**Основные компоненты файла .docx:**

1. docProps: содержит XML-файлы, в которых хранятся свойства документа, такие как название, автор и дата создания.
2. _rels: содержит XML-файлы, определяющие взаимосвязи между различными частями документа.
3. word: содержит основное содержимое документа, включая текст, изображения и информацию о форматировании.
4. document.xml: содержит фактическое содержимое документа, сохраненное в формате XML.
5. fontTable.xml: содержит информацию о шрифтах, используемых в документе.
6. settings.xml : содержит настройки для документа, такие как поля страницы и информация о верхнем и нижнем колонтитулах.
7. styles.xml : содержит стили, используемые в документе, такие как стили заголовков и абзацев.
8. [Content_Types].xml: определяет типы содержимого, которые включены в документ.

Для работы с документами формата .docx используется модуль XWPF (XML Word Processing Format).

### Класс WordDOCX

Предназначен для изменения содержимого документов формата .docx. Он предоставляет функциональность для замены текстовых меток на указанные значения.

Документы формата .docx содержат текстовые метки (теги) для замены. В процессе редактирования эти теги могут быть разбиты на несколько частей объектами XWPFRun. Это может случиться, например, если документ был сохранен в Word с форматированием, разделяющим теги на несколько частей. Для восстановления и корректной замены таких тегов в классе WordDOCX реализована специальная логика.

**Работа с разбитыми тегами**

1. Проверка и восстановление тегов:

- Метод iterateThroughRuns проверяет все объекты XWPFRun в абзаце и склеивает текст тегов, разделенных на части.
- Если обнаруживается символ $, метод начинает склеивать текст до тех пор, пока не встретится закрывающая скобка }.
- Склеенный текст проверяется на наличие полного тега, и при его обнаружении выполняется замена на значение из карты тегов.

2. Замена текста в разбитых тегах:

- При обнаружении полного тега метод replaceWord заменяет текст в объекте XWPFRun на соответствующее значение.
- Если текст содержит специальные символы, такие как флажки, метод getCheckboxSymbol возвращает соответствующий символ.

3. Сохранение изменений

- После замены всех тегов документ сохраняется с помощью метода saveFile, который записывает изменения в указанный файл.

## <a name="Authors"></a> 5. Работа с несколькими авторами

Для обработки документов с несколькими авторами в системе предусмотрены специальные механизмы, позволяющие гибко управлять файлами и тегами, в зависимости от количества авторов. Реализована логика работы с тегами и файлами для разных типов авторов и их количества.

### 1. Обработка файлов для первого и дополнительных авторов (SharedTagProcessor).

Файлы, содержащие в названии ключевые слова *main* и *additional*, предназначены для первого и остальных авторов соответственно. Если количество авторов превышает четыре, создаются дополнительные файлы additional для авторов 5-7, 8-10 и т.д.

Теги для авторов в файлах распределяются следующим образом:

- Первый автор: key_ria_author1
- Второй автор: key_ria_author2
- Третий автор: key_ria_author3
- Четвёртый автор: key_ria_author4
- Пятый автор: key_ria_author2
- Шестой автор: key_ria_author3
- Седьмой автор: key_ria_author4
- Восьмой автор: key_ria_author2 и так далее.

Теги авторов сохраняются в классе Authors, где для каждого автора предусмотрены соответствующие теги.

### 2. Обработка файлов для каждого автора (MultiTagProcessor class).

Файлы, содержащие в названии ключевое слово *multi*, предназначены для каждого автора отдельно и генерируются для каждого из них. При этом используются теги key_ria_author1 для всех авторов. Для каждого автора создается объект класса Authors с тегами key_ria_author1.

### 3. Блоковая обработка шаблонов (BlockProcessor).

Файлы, содержащие в названии ключевое слово *block*, предназначены для автоматического дублирования фрагментов текста. С помощью этого режима производится замена переменных, обеспечивая корректное форматирование и распределение контента. Основные возможности класса:

- Многоабзацная обработка команд.  
  Класс сканирует документ на наличие многострочных команд, начинающихся, например, с символа `$\{DUPLICATE_AUTHORS(`, и объединяет разбитые на несколько абзацев фрагменты команды в единый блок для дальнейшей обработки.

- Поддержка режимов дублирования.  
  В зависимости от команды и её расположения в документе (обычный абзац или ячейка таблицы) применяется один из режимов:
  - **newline:** каждая копия вставляется в отдельный абзац (новая строка);
  - **space:** все копии объединяются в один абзац, разделённые пробелами.

- Сохранение форматирования.  
  При обработке блока извлекаются стили отдельных частей текста (шрифт, размер, цвет, жирность и т.д.). Такой подход позволяет при вставке копий сохранить исходное форматирование.

- Динамическая замена переменных.  
  Метод `replaceXInVariables` заменяет шаблонные теги вида `key_ria_authorX` на соответствующий номер автора (например, `key_ria_author1`, `key_ria_author2` и т.д.), что обеспечивает корректное распределение информации между несколькими авторами.

**Примеры написания команд.**

1. Команда DUPLICATE

Команда DUPLICATE используется для дублирования указанного фрагмента текста заданное число раз. Можно задать количество копий, а также выбрать режим дублирования.

- Пример без указания режима (используется режим по умолчанию, например, newline):
  ```
  ${DUPLICATE(3)[Текст для дублирования]}
  ```

- Пример с явным указанием режима newline:
  ```
  ${DUPLICATE(3, newline)[Текст для дублирования]}
  ```

- Пример с режимом space (копии вставляются в один абзац, разделённые пробелом):
  ```
  ${DUPLICATE(3, space)[Текст для дублирования]}
  ```

2. Команда DUPLICATE_AUTHORS

Команда **DUPLICATE_AUTHORS** предназначена для дублирования текста с автоматической подстановкой номеров авторов в шаблонные теги в соответствии с их количеством. Вместо фиксированного числа копий используется ключевое слово `count_authors`, значение которого задаётся на стартовом экране (ViewModelStartScreen).

- Пример без указания режима:
  ```
  ${DUPLICATE_AUTHORS(count_authors)[Текст для автора ${key_ria_authorX_text}]}
  ```

- Пример с режимом newline:
  ```
  ${DUPLICATE_AUTHORS(count_authors, newline)[Текст для автора ${key_ria_authorX_text}]}
  ```

- Пример с режимом space:
  ```
  ${DUPLICATE_AUTHORS(count_authors, space)[Текст для автора ${key_ria_authorX_text}]}
  ```

В каждом из этих примеров содержимое, заключённое в квадратные скобки, будет продублировано указанное число раз, а внутри текста будут автоматически заменены шаблонные переменные для каждого автора. Пример команды `DUPLICATE_AUTHORS` с режимом `newline` при `count_authors = 3`:

```
Текст для автора ${key_ria_author1_text}
Текст для автора ${key_ria_author2_text}
Текст для автора ${key_ria_author3_text}
```

## <a name="ConvertPDF"></a> 6. Конвертация в PDF

Для преобразования документов формата DOCX в PDF в проекте используется класс **PdfConverter**. Он автоматизирует процесс, обеспечивая кросс-платформенную поддержку и корректное сохранение форматирования исходных файлов. Основные возможности класса:

1. Чтение файлов из директории.  
PdfConverter ищет все файлы с расширением `.docx` в папке **Word** внутри указанной выходной директории (после генерации). При отсутствии папки **PDF** она создаётся для сохранения конвертированных файлов.

2. Выбор метода конвертации в зависимости от операционной системы:  
- **Windows:** Если операционная система Windows, применяется API [documents4j](https://github.com/documents4j/documents4j) (метод `convertWithDocuments4j`), который выполняет конвертацию через вызов локального конвертера.  
- **Другие ОС:** Если используется система Linux, запускается LibreOffice в headless-режиме (метод `convertWithLibreOffice`), что позволяет конвертировать документ без открытия графического интерфейса.

## <a name="Window"></a> 7. Оконное приложение

В приложении реализовано 3 различных окна, каждое из которых предназначено для своих задач:

**ViewModelStartScreen**

На этом окне выбирается количество авторов и то, с помощью чего будет сгенерированы документы с использованием текстовых полей или с помощью CSV таблицы.
Выбор количества авторов реализовано в виде ComboBox c числами от 1 до 15(при необходимости количество авторов можно увелить).

**ViewModelTextFields**

Для генерации нужно выбрать заранее размеченный тегами файл нажимая на кнопку "Выбор файлов (doc/docx)"
Генерируются тексовые поля и кнопки с названиями выбранных файлов, которые отображаются в ScrollPaneTextFields и ScrollPaneButtons.

Текстовые поля в ScrollPaneTextFields отображаются после того, как выбраны необходимые файлы и считаются теги из файлов и количество авторов, также в текстовых полях появляются подсказки в виде соответсвующих каждому текстовому полю тега без фигурных скобок и знака $.

Кнопки на ScrollPaneButtons используются для того, чтобы отображать текстовые поля относящиеся к определенному файлу или для отображения всех текстовых полей.

После заполения текстовых полей для генерации документов нужно нажать кнопку "Генерация документов".

**ViewModelTable**

Выбираются необходимые файлы, после чего в папке появляется csv-таблица с тегами из этих файлов. После заполнения всех тегов нужно сохранить изменения в таблице и закрыть файл и нажать на кнопку "Генерация документов". Таблица использует стандартную для excel кодироку cp-1251 для корректного отображения как латинских, так и русских букв.

**Дополнительные сведения**

Документы генерируются с помощью метода generateDocument() из класса DocumentGenerator.

Также у ViewModelTable и ViewModelTextFields есть кнопка назад, которая уничтожает  Frame окна и будет создано заново если окно будет вновь открыто с помощью соотвествущей кнопки на стартовом экране. 

## <a name="Testing"></a> 8. Тестирование

В рамках тестирования выполнен анализ времени генерации документов. Тестирование проводилось на программе, генерирующей файлы `.docx`, содержащие абзацы, теги и таблицы, при этом изучалось влияание объема данных на процесс генерации.

### Характеристики ноутбука

| **Параметр**           | **Значение**                |
|------------------------|-----------------------------|
| **Процессор**          | AMD Ryzen 5 7000 Series     |
| **Оперативная память** | 16 GB DDR5                  |
| **Накопитель**         | SSD 1024 GB                 |
| **ОС**                 | Windows 11 Pro              |
| **Графика**            | NVIDIA GeForce GTX 4060     |


### Сводная таблица тестовых данных

| **Тип файла** | **Слов в файле** | **Количество файлов** | **Тегов на файл** | **Общее время генерации (сек.)** | **Среднее время на файл (сек.)** |
|---------------|------------------|-----------------------|-------------------|----------------------------------|----------------------------------|
| **Small**   | 1 500            | 100                   | 540               | 4,702                            | 0,04702                         |
| **Medium**  | 10 000           | 50                    | 2 600             | 10,770                           | 0,21539                         |
| **Huge**    | 50 000           | 10                    | 5 500             | 99,583                           | 9,95829                         |

### Примечания

- **Small** – небольшие документы с минимальным числом данных, их можно сравнить с образцами штатных документов. Данный пункт включает в себя базовую скорость.
- **Medium** - абзацы и теги, файлы среднего объема. Данные файлы позволяют оценить скорость обработки при стандартной нагрузке.
- **Huge** - максимальное число тегов и таблиц. Идеально для тестирование скорости обработки при столкновении с экстремальной нагрузкой.

## <a name="Problems"></a> 9. Возникшие проблемы

#### 1. Ошибка компилятора. Решено.

>ERROR StatusLogger Log4j2 could not find a logging implementation. Please add log4j-core to the classpath. Using Simple Logger to log to...

В intellij зависимость log4j по какой-то причине не была добавлена в путь к классам. [Решение проблемы](https://stackoverflow.com/questions/47881821/error-statuslogger-log4j2-could-not-find-a-logging-implementation).

Добавляет зависимости [log4j-core](https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core) и [log4j-api](https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-api) в pom.xml:

```
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-api</artifactId>
    <version>2.23.1</version>
</dependency>

<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.23.1</version>
</dependency>
```

После перезагрузить проект Maven.

#### 2. Проблема шрифта и размера при замене слова в .docx. Решено.

#### 2.1.  Решение каждого варианта вручную

При реализации метода replaceParagraph таким образом:

```
private void replaceParagraph(XWPFParagraph paragraph, String tag, String replaceWord){
	String paragraphText = paragraph.getParagraphText();
	if (paragraphText != null && paragraphText.contains(tag)) {
		String updatedParagraphText = paragraphText.replace(tag, replaceWord);
		while (paragraph.getRuns().size() > 0) {
			paragraph.removeRun(0);
		}
		XWPFRun newRun = paragraph.createRun();
		newRun.setText(updatedParagraphText);
	}
}
```

возникает проблема с XWPFRun newRun, так как createRun() создает новый текстовый элемент с стилем по умолчанию, который обычно является шрифтом Calibri и размером 11.

Предпологаемое решение проблемы: 

```
private void replaceParagraph(XWPFParagraph paragraph, String tag, String replaceWord){
    for (XWPFRun run: paragraph.getRuns()){
        String paragraphText = run.getText(0);
        if (paragraphText != null && paragraphText.contains(tag)) {
            String updatedParagraphText = paragraphText.replace(tag, replaceWord);
            run.setText(updatedParagraphText, 0);
        }
    }
}
```

Однако в одном параграфе текст может быть разбит на несколько текстовых элементов из-за изменений стилей форматирования.
Таким образом наш runs может выглядеть так:

**Первый случай:**

```
0 = ФИО: ${
1 = fio
2 = }
```

или 

```
0 = ФИО:
1 = ${
2 = fio
3 = }
```

**Второй случай:**

```
0 = ФИО:
1 = $
2 = {
3 = fio
4 = }
```

Решение этой проблемы от нас реализовано немного кастыльно.

- replaceVariableFirstCase - реализация первого случая. Решили искать "\${" в runs, он может быть в объекте c текстом или в отдельном объекте XWPFRun. После нахождения меняем "\${" на replaceWord, остальные объекты меняем на пустое значение, ибо с удалением объекта могли возникнуть затруднения при разбиянии на методов. Итоговой вид:

```
0 = ФИО: <Значение>
1 = ""
2 = ""
```

или 

```
0 = ФИО:
1 = <Значение>
2 = ""
3 = ""
```

- replaceVariableSecondCase - реализация второго случая. Решили реализовать подобно первому, только будем искать "\$" в runs. После нахождения "\$" меняем на replaceWord, остальные объекты, включая отдельно "\{", меняем на пустое значение. Итоговой вид:

```
0 = ФИО:
1 = <Значение>
2 = ""
3 = ""
4 = ""
```

Также реализиованные дополнительные методы для оптимизации:

- replaceWord - заменяет указанное слово в тексте объекта XWPFRun на другое слово

- replaceTextAndRemoveBrace - заменяет указанный текст в объекте XWPFRun на пустую строку. Могут быть случаи, когда после "\}" в объекте может быть продолжение текста. В таком случае меняем его на пустое значение, другой текст не меняем.

**Возможные проблемы в будущем:**

Может возникнуть третий случай по типу:

```
0 = ФИО: ${
1 = fio}
```

Пока мы не встречались с таким типом, при необходимости подумаем, как исправить этот случай. 

Еще может возникнуть проблема: разбиена тега в тексте между разными объектами XWPFRun. Например:

```
0 = Дата рождения: ${
1 = birth
2 = _
3 = date
4 = }
```

В таком случае остается только подбирать теги или думать, как исправить этот случай.

Коммит: [6b786094e3ad8333c4180ce55487a92bd99c74fe](https://github.com/stifell/template-process/commit/6b786094e3ad8333c4180ce55487a92bd99c74fe).

#### 2.2. Восстановление тега для замены (оптимальное решение).

Было решено не писать вручную каждый возможный случай разбиения тега. Вместо этого будем восстанавливать теги.

Сначала выполняется проверка абзаца на наличие частей тега, начиная с указанного индекса в списке текстовых объектов. Он ищет символы "\$", "\{", и "\}" в тексте абзаца и возвращает индекс при нахождении "\$", от которого следует продолжать замену текста. При этом есть проверка, что после "\$" идет тег.

Затем есть два варианта: находится полноценный тег или разбитый тег. 

1. При нахождении полноценного тега идет обычная замена, после опять проверка на наличие тега, меняем индекс при положительной проверки.

2. При разбитом теге поиск символа "\$", что может указывать на начало тега, метод объединяет текст из последующих объектов, пока не будет найден символ "\}". Затем замена текста в текущем объекте на полученный текст. После опять проверка на наличие тега и замена индекса.

Разбор алгоритма:

>Князь равнодушно замолк, ${fio}, с свойственною ей придворною и женскою ловкостью и быстротою такта, захотела и щелкануть князя за то, что он дерзнул так отозваться о лице, рекомендованном императрице, и в то же время утешить его.

1. Проверка абзаца на наличие тега (метод checkTextParagraph). При нахождении начинается с индекса начала тега (index = 5).

- Начальный разбитый тег:

```
5 = $
6 = {
7 = fio
8 = }
9 = ...
```

2. Так как тег разбитый, следующих шаг его восстановление. Символы в объекте, относящиеся к тегу, меняем на пустое значение. Могут быть проблемы по типу: "\}, какой-то текст или даже тег" в одном объекте. В таком случае есть проверка (метод checkOptions).

- Восстановление тега:

```
5 = ${fio}
6 = ""
7 = ""
8 = ""
9 = ...
```

3. Замена тега в тексте на его значение из словаря (метод replaceWord).

- Замена тега:

```
0 = <Значение>
1 = ""
2 = ""
3 = ""
4 = ...
```

Итог:

>Князь равнодушно замолк, Анна Павловна, с свойственною ей придворною и женскою ловкостью и быстротою такта, захотела и щелкануть князя за то, что он дерзнул так отозваться о лице, рекомендованном императрице, и в то же время утешить его.

Также могут быть неразбитые теги, в таком случае ничего восстанавливать не надо, простая замена.

Такая реализация решает проблему с разбинием слов в теге, не нужно подбирать теги и бояться, что docx волшебный способом их разобьет. Еще добавлен ход по абзацу, чтобы найти тег и менять его с индекса начала тега. 

Коммит: [ff49c85abdf934bfda9f00441c9e9938be264dbf](https://github.com/stifell/template-process/commit/ff49c85abdf934bfda9f00441c9e9938be264dbf).

## <a name="License"></a> 10. Лицензия

Этот проект распространяется под лицензией GNU General Public License v3.0.

## <a name="ProjectAuthors"></a> 11. Авторы

1. [Матюшкин Денис](https://github.com/stifell)
2. [Миронов Дмитрий](https://github.com/Zeliboba-Android)